// parse a single path portion
import { parseClass } from './brace-expressions.js';
import { unescape } from './unescape.js';
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
export class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST?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</sl:data></sl:binding></mx:renderer><sl:productIdRange xmlns:sl="http://www.microsoft.com/DRM/XrML2/SL/v2" value="{30a42c86-b7a0-4a34-8c90-ff177cb2acb7}"></sl:productIdRange><sl:externalValidator xmlns:sl="http://www.microsoft.com/DRM/XrML2/SL/v2"><sl:type>msft:sl/externalValidator/generic</sl:type><sl:data Algorithm="msft:rm/algorithm/flags/1.0">DAAAAAEAAAABAAAA</sl:data></sl:externalValidator></r:allConditions></r:grant><r:issuer><Signature xmlns="http://www.w3.org/2000/09/xmldsig#"><SignedInfo><CanonicalizationMethod Algorithm="http://www.microsoft.com/xrml/lwc14n"/><SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/><Reference><Transforms><Transform Algorithm="urn:mpeg:mpeg21:2003:01-REL-R-NS:licenseTransform"/><Transform Algorithm="http://www.microsoft.com/xrml/lwc14n"/></Transforms><DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/><DigestValue>kongJFvfUPdW/oOc7dDRQu/nGqI=</DigestValue></Reference></SignedInfo><SignatureValue>tON6FOEDHIfH5LnuK/IL1cJciRata1hV6+Y9B7D6gTdxaLzUztfywNo9FA4l1OrYdv8tTzh3GMwwkuJn+lek+Q+itzRDbUEkPVZWuCkwQPFA4BnYFnBwS2yuNzwEf+cxrqQoLhi3zvV3egXaMxIseabMjaA8Dm4pqx4UFxWM8BFuzGirgj/CUOUTFtbkPXP08Wuvmt2+PbRXhBxwhENvaQLzUxcNa4E1ZLjNY5/g0aWrkdcnX8chdQPbpCc4QV+rzC3NrBF1++nsx3QO/KETi9oqFymXPLbjshcr2LtIozZqKjHSVtHhsX8I3VqqtMMO9acyP1X+loeTFGX3Vtp5rQ==</SignatureValue><KeyInfo><KeyValue><RSAKeyValue><Modulus>tajcnLtdaeK0abuL2BpVC7obdfSChnHAx7TSn/37DwbTDegkDkEnbr0YyO/Q5Jluj5QD897+nWW54RDbYYTdNgWjyUpwYEJFXSZtd8LFK2mbIjKfG2HIShp6JJARlrgObR89a1EH716nP3PbJk6PWQa6VfjBzPQUgSVywIRU+OKbnzNbUVmQ/rAN6+AN/8fRmFhyKqOAiV/Np2jBtGNxLXm9ebMdm5cB8/YNrjp5Ey0nyAtYvovb0B7wnQZfolMF+OFiqzWJo2Ze0O7WHsWBHtIlGR3+c/IjxUJAsI7O3U4hncCZdvlC5GORI2YL9YHZgU9guSPLhAybQ3IGg7LBuQ==</Modulus><Exponent>AQAB</Exponent></RSAKeyValue></KeyValue></KeyInfo></Signature><r:details><r:timeOfIssue>2016-01-01T00:00:00Z</r:timeOfIssue></r:details></r:issuer><r:otherInfo xmlns:r="urn:mpeg:mpeg21:2003:01-REL-R-NS"><tm:infoTables xmlns:tm="http://www.microsoft.com/DRM/XrML2/TM/v2"><tm:infoList tag="#global"><tm:infoStr name="licenseType">msft:sl/EUL/PHONE/PUBLIC</tm:infoStr><tm:infoStr name="licenseCategory">msft:sl/EUL/PHONE/PUBLIC</tm:infoStr><tm:infoStr name="licenseVersion">2.0</tm:infoStr><tm:infoStr name="licensorUrl">http://licensing.microsoft.com</tm:infoStr><tm:infoStr name="issuanceCertificateId">{7e3094cf-ce3e-4ed4-8c8c-20c2be1add03}</tm:infoStr><tm:infoStr name="productSkuId">{30a42c86-b7a0-4a34-8c90-ff177cb2acb7}</tm:infoStr><tm:infoStr name="privateCertificateId">{0bffcd1d-1af5-4a2b-9715-09bc032a3140}</tm:infoStr><tm:infoStr name="applicationId">{55c92734-d682-4d71-983e-d6ec3f16059f}</tm:infoStr><tm:infoStr name="pkeyConfigLicenseId">{71ce6518-3581-46da-948d-083c57061836}</tm:infoStr><tm:infoStr name="licenseNamespace">msft:spp/namespace/ActiveDirectory</tm:infoStr><tm:infoStr name="productName">Windows(R), csvlk-pack edition</tm:infoStr><tm:infoStr name="productAuthor">Microsoft Corporation</tm:infoStr><tm:infoStr name="productDescription">Windows(R) Operating System, VOLUME_KMS_W10 channel</tm:infoStr><tm:infoStr name="UXDifferentiator">VOLUME_KMS</tm:infoStr><tm:infoStr name="Family">csvlk-pack</tm:infoStr><tm:infoStr name="ProductKeyGroupUniqueness">WINDOWS6.2</tm:infoStr><tm:infoStr name="hwid:ootGrace">0</tm:infoStr><tm:infoStr name="phone:policy">EA8AAHdmVUQAAQABeAEAADMiEQAAAQABABEQAwAAAAIAAAAAAAAAAAAAAAAAAAAhAAAAAAEAAAAAAAAAAQAAAAH//////////////////////////////////////////+U8QE9dvpMIJ1sSQ6dZPBkQOYuu5nP4mV70s4cDnTro2AUBAAH+AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACy++cpA0TchfKej1975jtgNwFQqw74F3zxfiog+EVT2nBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD++MQ4HdAsHhcj8TTBafDaCzfuaJYlE4a9jhX1H8YYD5YEZdTD+pWPi+hvwrTXV6sDlgzbfk+E2YVi7etMkxbanfZgB75THAtClKvY0As3OBN+oxILTcnnTFwHSiNUb6gzQiCqlQjWnjmcR3wFblBHg2XPpfLsA+NcQE6lv4mz8c7ivQ1ouUUDc0ob14AIosJMGsdTumFNHgkB+qmivko15mBIHz2nm7VJBKVR9gNrL2ujCdsto9P9llQH2IsSV2LX+JvncexL9xIfqg+WcB7xKFJ4W+xUyCEAvQDtBHT2gOBNEdNcTfzIjpW98aQEjTNBB6fXQTcXZT7qur2mhg6hb/riGxU6aaaylUvvYqB/AcatpCQikZa6vBxuRcey880Fu6tSVTmoux8pYNgrAswtPQEFJQj960d1ZT8qKVGOVXhIBJtt0f3mI3omlBq9gyOkz20Jb8Z6JOpoSQerRloMQm7TfghVafeFFHDODkJJX3M5UBwfCl6TDU30lYvXbNGgj/RYGiEAYAPuxTKjiGzVO/JZMjwHCAspNTctZ08x4HWoLdxlQdVQBWhmikTpy0/GJKkhAjG0Nns suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to protect against dots and such.
                    // '.' and '..' cannot match unless the pattern is that exactly,
                    // even if it starts with . or dot:true is set.
                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
                    if (!dotTravAllowed) {
                        const aps = addPatternStart;
                        // check if we have a possibility of matching . or ..,
                        // and prevent that.
                        const needNoTrav = 
                        // dots are allowed, and the pattern starts with [ or .
                        (dot && aps.has(src.charAt(0))) ||
                            // the pattern starts with \., and then [ or .
                            (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
                            // the pattern starts with \.\., and then [ or .
                            (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
                        // no need to prevent dots if it can't match a dot, or if a
                        // sub-pattern will be preventing it anyway.
                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
                    }
                }
            }
            // append the "end of path portion" pattern to negation tails
            let end = '';
            if (this.isEnd() &&
                this.#root.#filledNegs &&
                this.#parent?.type === '!') {
                end = '(?:$|\\/)';
            }
            const final = start + src + end;
            return [
                final,
                unescape(src),
                (this.#hasMagic = !!this.#hasMagic),
                this.#uflag,
            ];
        }
        // We need to calculate the body *twice* if it's a repeat pattern
        // at the start, once in nodot mode, then again in dot mode, so a
        // pattern like *(?) can match 'x.y'
        const repeated = this.type === '*' || this.type === '+';
        // some kind of extglob
        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
            // invalid extglob, has to at least be *something* present, if it's
            // the entire path portion.
            const s = this.toString();
            this.#parts = [s];
            this.type = null;
            this.#hasMagic = undefined;
            return [s, unescape(this.toString()), false, false];
        }
        // XXX abstract out this map method
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot
            ? ''
            : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
            bodyDotAllowed = '';
        }
        if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        // an empty !() is exactly equivalent to a starNoEmpty
        let final = '';
        if (this.type === '!' && this.#emptyExt) {
            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
        }
        else {
            const close = this.type === '!'
                ? // !() must match something,but !(x) can match ''
                    '))' +
                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +
                        star +
                        ')'
                : this.type === '@'
                    ? ')'
                    : this.type === '?'
                        ? ')?'
                        : this.type === '+' && bodyDotAllowed
                            ? ')'
                            : this.type === '*' && bodyDotAllowed
                                ? `)?`
                                : `)${this.type}`;
            final = start + body + close;
        }
        return [
            final,
            unescape(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
        ];
    }
    #partsToRegExp(dot) {
        return this.#parts
            .map(p => {
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */
            if (typeof p === 'string') {
                throw new Error('string type in extglob ast??');
            }
            /* c8 ignore stop */
            // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
            this.#uflag = this.#uflag || uflag;
            return re;
        })
            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
            .join('|');
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = '';
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials.has(c) ? '\\' : '') + c;
                continue;
            }
            if (c === '\\') {
                if (i === glob.length - 1) {
                    re += '\\\\';
                }
                else {
                    escaping = true;
                }
                continue;
            }
            if (c === '[') {
                const [src, needUflag, consumed, magic] = parseClass(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === '*') {
                if (noEmpty && glob === '*')
                    re += starNoEmpty;
                else
                    re += star;
                hasMagic = true;
                continue;
            }
            if (c === '?') {
                re += qmark;
                hasMagic = true;
                continue;
            }
            re += regExpEscape(c);
        }
        return [re, unescape(glob), !!hasMagic, uflag];
    }
}
//# sourceMappingURL=ast.js.map