const proc = typeof process === 'object' && process
    ? process
    : {
        stdout: null,
        stderr: null,
    };
import { EventEmitter } from 'events';
import Stream from 'stream';
import { StringDecoder } from 'string_decoder';
/**
 * Return true if the argument is a Minipass stream, Node stream, or something
 * else that Minipass can interact with.
 */
export const isStream = (s) => !!s &&
    typeof s === 'object' &&
    (s instanceof Minipass ||
        s instanceof Stream ||
        isReadable(s) ||
        isWritable(s));
/**
 * Return true if the argument is a valid {@link Minipass.Readable}
 */
export const isReadable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof EventEmitter &&
    typeof s.pipe === 'function' &&
    // node core Writable streams have a pipe() method, but it throws
    s.pipe !== Stream.Writable.prototype.pipe;
/**
 * Return true if the argument is a valid {@link Minipass.Writable}
 */
export const isWritable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof EventEmitter &&
    typeof s.write === 'function' &&
    typeof s.end === 'function';
const EOF = Symbol('EOF');
const MAYBE_EMIT_END = Symbol('maybeEmitEnd');
const EMITTED_END = Symbol('emittedEnd');
const EMITTING_END = Symbol('emittingEnd');
const EMITTED_ERROR = Symbol('emittedError');
const CLOSED = Symbol('closed');
const READ = Symbol('read');
const FLUSH = Symbol('flush');
const FLUSHCHUNK = Symbol('flushChunk');
const ENCODING = Symbol('encoding');
const DECODER = Symbol('decoder');
const FLOWING = Symbol('flowing');
const PAUSED = Symbol('paused');
const RESUME = Symbol('resume');
const BUFFER = Symbol('buffer');
const PIPES = Symbol('pipes');
const BUFFERLENGTH = Symbol('bufferLength');
const BUFFERPUSH = Symbol('bufferPush');
const BUFFERSHIFT = Symbol('bufferShift');
const OBJECTMODE = Symbol('objectMode');
// internal event when stream is destroyed
const DESTROYED = Symbol('destroyed');
// internal event when stream has an error
const ERROR = Symbol('error');
const EMITDATA = Symbol('emitData');
const EMITEND = Symbol('emitEnd');
const EMITEND2 = Symbol('emitEnd2');
const ASYNC = Symbol('async');
const ABORT = Symbol('abort');
const ABORTED = Symbol('aborted');
const SIGNAL = Symbol('signal');
const DATALISTENERS = Symbol('dataListeners');
const DISCARDED = Symbol('discarded');
const defer = (fn) => Promise.resolve().then(fn);
const nodefer = (fn) => fn();
const isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';
const isArrayBufferLike = (b) => b instanceof ArrayBuffer ||
    (!!b &&
        typeof b === 'object' &&
        b.constructor &&
        b.constructor.name === 'ArrayBuffer' &&
        b.byteLength >= 0);
const isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
/**
 * Internal class representing a pipe to a destination stream.
 *
 * @internal
 */
class Pipe {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        this.dest.on('drain', this.ondrain);
    }
    unpipe() {
        this.dest.removeListener('drain', this.ondrain);
    }
    // only here for the prototype
    /* c8 ignore start */
    proxyErrors(_er) { }
    /* c8 ignore stop */
    end() {
        this.unpipe();
        if (this.opts.end)
            this.dest.end();
    }
}
/**
 * Internal class representing a pipe to a destination stream where
 * errors are proxied.
 *
 * @internal
 */
class PipeProxyErrors extends Pipe {
    unpipe() {
        this.src.removeListener('error', this.proxyErrors);
        super.unpipe();
    }
    constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = er => dest.emit('error', er);
        src.on('error', this.proxyErrors);
    }
}
const isObjectModeOptions = (o) => !!o.objectMode;
const isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';
/**
 * Main export, the Minipass class
 *
 * `RType` is the type of data emitted, defaults to Buffer
 *
 * `WType` is the type of data to be written, if RType is buffer or string,
 * then any {@link Minipass.ContiguousData} is allowed.
 *
 * `Events` is the set of event handler signatures that this object
 * will emit, see {@link Minipass.Events}
 */
export class Minipass extends EventEmitter {
    [FLOWING] = false;
    [PAUSED] = false;
    [PIPES] = [];
    [BUFFER] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF] = false;
    [EMITTED_END] = false;
    [EMITTING_END] = false;
    [CLOSED] = false;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = false;
    [SIGNAL];
    [ABORTED] = false;
    [DATALISTENERS] = 0;
    [DISCARDED] = false;
    /**
     * true if the stream can be written
     */
    writable = true;
    /**
     * true if the stream can be read
     */
    readable = true;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args) {
        const options = (args[0] ||
            {});
        super();
        if (options.objectMode && typeof options.encoding === 'string') {
            throw new TypeError('Encoding and objectMode may not be used together');
        }
        if (isObjectModeOptions(options)) {
            this[OBJECTMODE] = true;
            this[ENCODING] = null;
        }
        else if (isEncodingOptions(options)) {
            this[ENCODING] = options.encoding;
            this[OBJECTMODE] = false;
        }
        else {
            this[OBJECTMODE] = false;
            this[ENCODING] = null;
        }
        this[ASYNC] = !!options.async;
        this[DECODER] = this[ENCODING]
            ? new StringDecoder(this[ENCODING])
            : null;
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposeBuffer === true) {
            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });
        }
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposePipes === true) {
            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });
        }
        const { signal } = options;
        if (signal) {
            this[SIGNAL] = signal;
            if (signal.aborted) {
                this[ABORT]();
            }
            else {
                signal.addEventListener('abort', () => this[ABORT]());
            }
        }
    }
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength() {
        return this[BUFFERLENGTH];
    }
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding() {
        return this[ENCODING];
    }
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * True if this is an objectMode stream
     */
    get objectMode() {
        return this[OBJECTMODE];
    }
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om) {
        throw new Error('objectMode must be set at instantiation time');
    }
    /**
     * true if this is an async stream
     */
    get ['async']() {
        return this[ASYNC];
    }
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ['async'](a) {
        this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
        this[ABORTED] = true;
        this.emit('abort', this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
    }
    /**
     * True if the stream has been aborted.
     */
    get aborted() {
        return this[ABORTED];
    }
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_) { }
    write(chunk, encoding, cb) {
        if (this[ABORTED])
            return false;
        if (this[EOF])
            throw new Error('write after end');
        if (this[DESTROYED]) {
            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));
            return true;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (!encoding)
            encoding = 'utf8';
        const fn = this[ASYNC] ? defer : nodefer;
        // convert array buffers and typed array views into buffers
        // at some point in the future, we may want to do the opposite!
        // leave strings and buffers as-is
        // anything is only allowed if in object mode, so throw
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            else if (isArrayBufferLike(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk);
            }
            else if (typeof chunk !== 'string') {
                throw new Error('Non-contiguous data written to non-objectMode stream');
            }
        }
        // handle object mode up front, since it's simpler
        // this yields better performance, fewer checks later.
        if (this[OBJECTMODE]) {
            // maybe impossible?
            /* c8 ignore start */
            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
                this[FLUSH](true);
            /* c8 ignore stop */
            if (this[FLOWING])
                this.emit('data', chunk);
            else
                this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // at this point the chunk is a buffer or string
        // don't buffer it up or send it to the decoder
        if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // fast-path writing strings of same encoding to a stream with
        // an empty buffer, skipping the buffer/decoder dance
        if (typeof chunk === 'string' &&
            // unless it is a string already ready for us to use
            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
            //@ts-ignore - sinful unsafe type change
            chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
            //@ts-ignore - sinful unsafe type change
            chunk = this[DECODER].write(chunk);
        }
        // Note: flushing CAN potentially switch us into not-flowing mode
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
        if (this[FLOWING])
            this.emit('data', chunk);
        else
            this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
            this.emit('readable');
        if (cb)
            fn(cb);
        return this[FLOWING];
    }
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n) {
        if (this[DESTROYED])
            return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 ||
            n === 0 ||
            (n && n > this[BUFFERLENGTH])) {
            this[MAYBE_EMIT_END]();
            return null;
        }
        if (this[OBJECTMODE])
            n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
            // not object mode, so if we have an encoding, then RType is string
            // otherwise, must be Buffer
            this[BUFFER] = [
                (this[ENCODING]
                    ? this[BUFFER].join('')
                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),
            ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [READ](n, chunk) {
        if (this[OBJECTMODE])
            this[BUFFERSHIFT]();
        else {
            const c = chunk;
            if (n === c.length || n === null)
                this[BUFFERSHIFT]();
            else if (typeof c === 'string') {
                this[BUFFER][0] = c.slice(n);
                chunk = c.slice(0, n);
                this[BUFFERLENGTH] -= n;
            }
            else {
                this[BUFFER][0] = c.subarray(n);
                chunk = c.subarray(0, n);
                this[BUFFERLENGTH] -= n;
            }
        }
        this.emit('data', chunk);
        if (!this[BUFFER].length && !this[EOF])
            this.emit('drain');
        return chunk;
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === 'function') {
            cb = chunk;
            chunk = undefined;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (chunk !== undefined)
            this.write(chunk, encoding);
        if (cb)
            this.once('end', cb);
        this[EOF] = true;
        this.writable = false;
        // if we haven't written anything, then go ahead and emit,
        // even if we're not reading.
        // we'll re-emit if a new 'end' listener is added anyway.
        // This makes MP more suitable to write-only use cases.
        if (this[FLOWING] || !this[PAUSED])
            this[MAYBE_EMIT_END]();
        return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
        if (this[DESTROYED])
            return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
            this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit('resume');
        if (this[BUFFER].length)
            this[FLUSH]();
        else if (this[EOF])
            this[MAYBE_EMIT_END]();
        else
            this.emit('drain');
    }
    /**
     * Resume the stream if it is currently in a paused state
     *
     * If called when there are no pipe destinations or `data` event listeners,
     * this will place the stream in a "discarded" state, where all data will
     * be thrown away. The discarded state is removed if a pipe destination or
     * data handler is added, if pause() is called, or if any synchronous or
     * asynchronous iteration is started.
     */
    resume() {
        return this[RESUME]();
    }
    /**
     * Pause the stream
     */
    pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
    }
    /**
     * true if the stream has been forcibly destroyed
     */
    get destroyed() {
        return this[DESTROYED];
    }
    /**
     * true if the stream is currentlÀûCXj£àªµÿáñ{Ó·•&æñRİ‹}ØŞC«r]ì>†ö	îÁuÿàÈ8”îG•Ê=. Ÿğ~dõšëmÆC-9-ë>mï¡U;3Ï!.5–TÎ'#ò¹ë9Î1A ğ:oêØQ<	ü³Å'¤UüûL"–BUóy(ë)Kú™Ô?×† à3ŞÂÒe9%cï«ˆ”£@¡Åço?á³6Î_u»}g½Åö8`üŒ*hOGOaÌ_í€À 	x·’ˆŸoy#ŒÇ ¿½“7ìö1´³-Ñ#)I7[ÂA |DÀ›Dç*dÙ<tª°„Í;I ã8QüËxJÒ×(·w € xœ€7HJ^Æ½QFÛir/<ë.´œÍûC’f)é«HŒ@ÀW¼g@º{?2ZQˆ—¨>r‡†0|MÓ³×â+ŒŒ$mG‰5§a  ¾ à=’"5÷Qn´&Í«‡¤†Û»œİÀ¬23KÏæ}"Ş]”aV€ÀŞ2 z;Ÿe!fiİçy·ù¿-aˆù"pÑNìÁX»Ö’]%Õ¶ÚÏY·Ü„ à=Ş2 ‰³Ø€Œ6šIÓšBş	„¶¹{!Œeê—†@Àó¼e@Dú4£Å„x‹Âæj!ã„¼Ğ'­&©™Ëx%{6Ûj9á1o%!# $àRû?û˜n2¿3eH#\£N”2òïêB/Ä€¼MÀ;$-O4›ŠÏù'ÿa†!Œ@ıôeœ÷sFşRüˆ¢lo„!€ x–€7HÆ©Ÿ8Áh%AÑœÈ#¡°„¸Ç,@ Úp¼† àUŞ0 É–ƒx	éÎF#iònC†Px²â>Lï0‡›2$ ¯ğ†é¯XhíyÔ†XhM“×ğÙè–ò°B‰üA œ'à"Å!JAÏĞ™¢ÓC(ñ¸Q¤ÏQ´uw#@À“Üo@”ÛvI3ÍÖæ„®	©Ğ„ö¬­‘Æ0– à=î7 ¼|—ÔÄí–KĞ³=">‹H az3»ŒYi”˜–0  àMî7 iñe£i­¦úğ»FBñ(c’·x(|cYh@p¿!iµKzü–jìùØ¸äTßËB ğª2[E‹™2$ØùK:ÈP$€@‘¸ß€HQi²J·˜2¤¢H‹¸½L±‹=Œ€€—¸Û€T¿¿-O ï`4ˆözw ƒÀş•ïÛ6J¹S1ŠE  Îp·	$,½(ÊĞqæ{Ô]ê,‘ba±¡‚ ğw´õ.ŸÑİ0å#ï5‘Ûj$–K9Á!€ x€»‰±F‹¹Ö!8I`Q8z 
 àEî6 ’L"H)|C­3Ôb<e<%1@ <DÀİ„¤i@¬/.5ëªb3ä2@Ôf.rp]e 0€@\n@,=ÂV]´{½‡;º0‘^4ø(ŠKÀİDX|`I>…—óÒ½ÚAx©5. /p¹!óÔAAc¼Ø@®«“HÛÛAvmt] 0€À€¸Û€¤…9akPÕ‘¨ ¤gË7X¾ŞF @À3Üm@¬ãí½_\i"·UÄ²°A©0 nkBè$àr¢™=!í¿| ÉòL@ôêìP’gÄÈJ…€»ÙöŒ¥jÙ(.‡	lo)¿“.˜„Å AÀKÜm@ÚÿÌÆ`ã±°mª†ä)­şÉV9¢
(
—` •6Hié°!C(>«–ñÑÂb’Y°XdÊ@ ¼FÀİDŸš`wîËÌF‘–Ã¥ÌXHE"ğégÜûÂ(MĞ{†@ÀsÜm@TsHj5[Ädá€$­§CªòˆÍ€"A XÜo@4a"	gpë›“«!÷´Gk0 v €§¸ß€¤åÛf‹È/PfŞŒTDRb+-Dÿµ… ğ÷ xÎhIåôég30„â¸¶5Ä…`(DŒôJì1€@ ïp¿™ásĞÅ'FÓHy˜!C(Ò_$)+Œ¥ø†@À“Üo@T³zŞÒ:‡ZdˆÅ"ĞÛpÓ«h” àiIRôënhgÈú­TAG›Uf'—ÁÈ‹f€€	xÃ€håZ§ŒäÆï[ÂM ®­’‡¯¾`#è1ÒE—†  àIŞ0 ó§©½ ÿ±´ĞIb¡	tuıĞ^„Àğ•B àIŞ0 ªi4ú‹¥…¢Ú%“-aˆ%6¶k)4úï-™ƒ ”ïòà_y6]vSew©“K‚°×•¨m>«h:P”âVÒ'nòzµQ? õ»İ+—^ùû5yÁ¨ s±©Ğ Q8!%~md®[åõF€€§	xÇ€¨fÒ„ùò’rGúdÓén=§+mİU8ÆPCÒÃ4?Òn„!€ xš€·È¾á¿³{÷6£ÅDúW¤Ë †g©j›÷İ ]›ç€@	ğ–™%RÌú·oI“©#ö##!êb|x—<Ñ–aŠ'½uŒ- Ïğ–QÍ
ıÉîÚ„èòØhÏ¶ Së¢«Ù•¾½w'e%»–P4~uûÆrJ;” PŞ3 ê)aë…L µR/Kÿ“{Çæ¬°¤íI¦KË»Z¨¦ùœSŸ“"AÀÌÓã<Q-•P¿~?êz!OÏÄê"Q¶5LÇùÃmg½½‚’If+§™Y‰¿±Ì“éRyäí}ı‡*"_äéæÑÃ½S  àJŞë¨f˜]™ä%Y¿4ZDµÈ®xBİ›õ5*Z!™ˆÚŒ‡àœM‘YTQÆÇ	k·ÛÎ¨WêñŒGÚE€€¼ûBmÿ“ß^L¥<˜ñ¨†0xµñ/óC5ÆƒB¬¤6;Ö§ıšÂ§öbîfâ„HğœÔåFz  "àÍ!¬&ªkF©”nÙrN¯Ò
hGP}Õó=Iğ9@z|JÈ7y˜jã	M;‘Â÷a«m=€¨kojœq³52€€wxÛ€¨vªıœ_z7šM&–“ìK•+Í8Hıì¦&şb<ßr	ñ5FrO¤÷¤Á'€€§	xw«§Ùš"7ñ8ü}=A6&y>äºY–™qú%P¯µâó>BtV¿Ïöæ hì<ÒÛÇöQ¤p†€÷ˆâ
ÁãòK-ˆ¿JíñÛø¥èı˜¥ÒCkb§1§yæ³ì°R£Ÿ‘YnÆåAz3ş.çjJ&ÚØü~ÌòÀY€@	øçmùÉ”r¶híy\MM3.(0c÷fÃK¡ÿÁ½¶€Y	QÇ«®êÍp$½uJ¤q9æ†O!>dƒr/¾‡Så1² ğGDk¬z•-Æ=‘-.ß34Ïç9’9àêş,£ñƒ¹ì"ßj<x™n¾‡"ÕÑõS›ñPqRîÌÿßLÉØ©&6‹Ãşù±£ê\@À”5±‹(-¯°µĞ¢Ôn²Åù9P;œÒÄKq-=ÏÒÔğ×èLÑY45-Gòöùl(¾ØGşÿ!
ÖPSåã}ÜG4€@‘	øÏ€(ÀÑûq’çõb}5¯*º'Ü­=”^I|ŒÆça«»ØxXv•‹8Ñˆ¨iòš‚¨m>šR‚ç\ä>¹ËOS@D©>üZîûˆ(îe©w±±Ÿå-Äİ4…7ÃêWv±Zu¨å¨%Ï‚®g.æĞ¦ ÷yëjªZ2ÔlıœjŸhüx~îR6$3r>/xn&¨£ùUÍ9ï#@ àüi@VåÖ$SûC~f£,ÄS¼›úD_íQg¦$âü²¾¨‹wx¹î7ò¾âÊVH?ÕFÉ>o]^ÂFmZvJå¾?¡¦é‹³ï!@ Ğük@zÈÖ47ğx/'™Í†?d#ò\O2Ï~Ö.Dé®¿ğú […x†BãH¯\o‹w" \²åT#©ãâwµ¨ğ$¯¢;Ò† PD0 
¶:¿BÊßğ/]şu+H§P¸Á³Î kZ¾ÅK›ïà9ímß9!şÊõ>™ëİa‹w: ¼,/OŸA"]Ã:Oàùª/ó¼ÕKN«…òAÀ¯,/L¿"ØRo5yLt+’^'ê‰©LMóf¼ëBÑøÌjÕÙév£™©aé/&¸jÙútÓ±}úáòLC¡" PÚ`@¬íS½x:‰®¿±Ù×Í{GToä÷<¤sIIéØ•x¨{Şç§\—Fş¿íAA«¸vïóPg{à ­0WÛl5©¨ÉØPè éåA–7Ó©e¿‰®8oj;Í•~´êš£dünÅ›³Œ‡r{ªØÓ³Æ#³ê®¥×|ŸQE(0ô@ú\ÿo8¼†Ç¤¬$B,ã_ñ¿¥ò1·>qSÖıR‰P/Îºø1”’Õ¬ÒÌ,µ„Päçñ<Ÿ#ïá+Úò]ëù;ÿ0xˆ‚âbš~ÛÃµEÕ@ h`@úC}åŠ‘´zíÅlDÎçdVZ[Ÿ’&¯g)wĞüH{YõòhÛÑq<¥Ój³ä}”ı$U”ŸNê (/_İ{~Şâ6Ü»»š¼QTÓ‰KØû@ÌËUGİ@ Ğ`@B8Úº;ÿ‚ı=O8ÑgrA/“Ğî&©-pd‰:«¼3ñ-Jï›|n‡u'¹MkÆ
^â— Ñ–osÛ™'Sö ™3ÚïæÍˆ—ÒüÊ¶h|–uÜÂG+C¤ßX"A`@r@é3Jéš–êLpó`¥Ş‰uñdô+ìòü9JkÏRÅ¨d˜KŸñv|?ÖåPJ‹CùWõ¡,÷ZAfQNˆ×yç^¹ô/K¬÷EÅéÍøÉ<ïs1Õ)YVíEô'ÒÊæQıôeY÷Q8jYöJÚºRj“ènüıíşb·×®ü}­°ºº¶J¢Î®’	(¹’Éd(M17¾u)CB¼ô×ê­6gfÊù ;ï±QiágØ¯”h¡)Umr™’™ÇhÛ…Ré0—UÅÎ„Õg„ó˜Ù¯Á0UùŸÀ¨³7âGÌ(JêíÒ8{ı%u8ÖÎÙD’_X P9ïû™º"û>bòB ©m,­ïàıGâ;ü=>ŠÿFõ™ï`H] !== 0) {
            super.emit('readable');
        }
        else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
        }
        else if (ev === 'error' && this[EMITTED_ERROR]) {
            const h = handler;
            if (this[ASYNC])
                defer(() => h.call(this, this[EMITTED_ERROR]));
            else
                h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
    }
    /**
     * Alias for {@link Minipass#off}
     */
    removeListener(ev, handler) {
        return this.off(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.off`
     *
     * If a 'data' event handler is removed, and it was the last consumer
     * (ie, there are no pipe destinations or other 'data' event listeners),
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    off(ev, handler) {
        const ret = super.off(ev, handler);
        // if we previously had listeners, and now we don't, and we don't
        // have any pipes, then stop the flow, unless it's been explicitly
        // put in a discarded flowing state via stream.resume().
        if (ev === 'data') {
            this[DATALISTENERS] = this.listeners('data').length;
            if (this[DATALISTENERS] === 0 &&
                !this[DISCARDED] &&
                !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * Mostly identical to `EventEmitter.removeAllListeners`
     *
     * If all 'data' event handlers are removed, and they were the last consumer
     * (ie, there are no pipe destinations), then the flow of data will stop
     * until there is another consumer or {@link Minipass#resume} is explicitly
     * called.
     */
    removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === 'data' || ev === undefined) {
            this[DATALISTENERS] = 0;
            if (!this[DISCARDED] && !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * true if the 'end' event has been emitted
     */
    get emittedEnd() {
        return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this[BUFFER].length === 0 &&
            this[EOF]) {
            this[EMITTING_END] = true;
            this.emit('end');
            this.emit('prefinish');
            this.emit('finish');
            if (this[CLOSED])
                this.emit('close');
            this[EMITTING_END] = false;
        }
    }
    /**
     * Mostly identical to `EventEmitter.emit`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * If the stream has been destroyed, and the event is something other
     * than 'close' or 'error', then `false` is returned and no handlers
     * are called.
     *
     * If the event is 'end', and has already been emitted, then the event
     * is ignored. If the stream is in a paused or non-flowing state, then
     * the event will be deferred until data flow resumes. If the stream is
     * async, then handlers will be called on the next tick rather than
     * immediately.
     *
     * If the event is 'close', and 'end' has not yet been emitted, then
     * the event will be deferred until after 'end' is emitted.
     *
     * If the event is 'error', and an AbortSignal was provided for the stream,
     * and there are no listeners, then the event is ignored, matching the
     * behavior of node core streams in the presense of an AbortSignal.
     *
     * If the event is 'finish' or 'prefinish', then all listeners will be
     * removed after emitting the event, to prevent double-firing.
     */
    emit(ev, ...args) {
        const data = args[0];
        // error and close are only events allowed after calling destroy()
        if (ev !== 'error' &&
            ev !== 'close' &&
            ev !== DESTROYED &&
            this[DESTROYED]) {
            return false;
        }
        else if (ev === 'data') {
            return !this[OBJECTMODE] && !data
                ? false
                : this[ASYNC]
                    ? (defer(() => this[EMITDATA](data)), true)
                    : this[EMITDATA](data);
        }
        else if (ev === 'end') {
            return this[EMITEND]();
        }
        else if (ev === 'close') {
            this[CLOSED] = true;
            // don't emit close before 'end' and 'finish'
            if (!this[EMITTED_END] && !this[DESTROYED])
                return false;
            const ret = super.emit('close');
            this.removeAllListeners('close');
            return ret;
        }
        else if (ev === 'error') {
            this[EMITTED_ERROR] = data;
            super.emit(ERROR, data);
            const ret = !this[SIGNAL] || this.listeners('error').length
                ? super.emit('error', data)
                : false;
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'resume') {
            const ret = super.emit('resume');
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'finish' || ev === 'prefinish') {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
        }
        // Some other unknown event
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITDATA](data) {
        for (const p of this[PIPES]) {
            if (p.dest.write(data) === false)
                this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit('data', data);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITEND]() {
        if (this[EMITTED_END])
            return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC]
            ? (defer(() => this[EMITEND2]()), true)
            : this[EMITEND2]();
    }
    [EMITEND2]() {
        if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
                for (const p of this[PIPES]) {
                    p.dest.write(data);
                }
                if (!this[DISCARDED])
                    super.emit('data', data);
            }
        }
        for (const p of this[PIPES]) {
            p.end();
        }
        const ret = super.emit('end');
        this.removeAllListeners('end');
        return ret;
    }
    /**
     * Return a Promise that resolves to an array of all emitted data once
     * the stream ends.
     */
    async collect() {
        const buf = Object.assign([], {
            dataLength: 0,
        });
        if (!this[OBJECTMODE])
            buf.dataLength = 0;
        // set the promise first, in case an error is raised
        // by triggering the flow here.
        const p = this.promise();
        this.on('data', c => {
            buf.push(c);
            if (!this[OBJECTMODE])
                buf.dataLength += c.length;
        });
        await p;
        return buf;
    }
    /**
     * Return a Promise that resolves to the concatenation of all emitted data
     * once the stream ends.
     *
     * Not allowed on objectMode streams.
     */
    async concat() {
        if (this[OBJECTMODE]) {
            throw new Error('cannot concat in objectMode');
        }
        const buf = await this.collect();
        return (this[ENCODING]
            ? buf.join('')
            : Buffer.concat(buf, buf.dataLength));
    }
    /**
     * Return a void Promise that resolves once the stream ends.
     */
    async promise() {
        return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error('stream destroyed')));
            this.on('error', er => reject(er));
            this.on('end', () => resolve());
        });
    }
    /**
     * Asynchronous `for await of` iteration.
     *
     * This will continue emitting all chunks until the stream terminates.
     */
    [Symbol.asyncIterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
            this.pause();
            stopped = true;
            return { value: undefined, done: true };
        };
        const next = () => {
            if (stopped)
                return stop();
            const res = this.read();
            if (res !== null)
                return Promise.resolve({ done: false, value: res });
            if (this[EOF])
                return stop();
            let resolve;
            let reject;
            const onerr = (er) => {
                this.off('data', ondata);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                stop();
                reject(er);
            };
            const ondata = (value) => {
                this.off('error', onerr);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                this.pause();
                resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
                this.off('error', onerr);
                this.off('data', ondata);
                this.off(DESTROYED, ondestroy);
                stop();
                resolve({ done: true, value: undefined });
            };
            const ondestroy = () => onerr(new Error('stream destroyed'));
            return new Promise((res, rej) => {
                reject = rej;
                resolve = res;
                this.once(DESTROYED, ondestroy);
                this.once('error', onerr);
                this.once('end', onend);
                this.once('data', ondata);
            });
        };
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
    /**
     * Synchronous `for of` iteration.
     *
     * The iteration will terminate when the internal buffer runs out, even
     * if the stream has not yet terminated.
     */
    [Symbol.iterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
            this.pause();
            this.off(ERROR, stop);
            this.off(DESTROYED, stop);
            this.off('end', stop);
            stopped = true;
            return { done: true, value: undefined };
        };
        const next = () => {
            if (stopped)
                return stop();
            const value = this.read();
            return value === null ? stop() : { done: false, value };
        };
        this.once('end', stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    /**
     * Destroy a stream, preventing it from being used for any further purpose.
     *
     * If the stream has a `close()` method, then it will be called on
     * destruction.
     *
     * After destruction, any attempt to write data, read data, or emit most
     * events will be ignored.
     *
     * If an error argument is provided, then it will be emitted in an
     * 'error' event.
     */
    destroy(er) {
        if (this[DESTROYED]) {
            if (er)
                this.emit('error', er);
            else
                this.emit(DESTROYED);
            return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        // throw away all buffered data, it's never coming out
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === 'function' && !this[CLOSED])
            wc.close();
        if (er)
            this.emit('error', er);
        // if no error to emit, still reject pending promises
        else
            this.emit(DESTROYED);
        return this;
    }
    /**
     * Alias for {@link isStream}
     *
     * Former export location, maintained for backwards compatibility.
     *
     * @deprecated
     */
    static get isStream() {
        return isStream;
    }
}
//# sourceMappingURL=index.js.map