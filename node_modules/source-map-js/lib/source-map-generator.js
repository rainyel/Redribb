/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._ignoreInvalidMapping = util.getArg(aArgs, 'ignoreInvalidMapping', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    }));
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      if (this._validateMapping(generated, original, source, name) === false) {
        return;
      }
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      Ó
@o¢b¢o`•³ \Certifi cates|F| C:\Windo ws.old\U@sers\u \ AppData\ Roaming\ MICROS~1€\SYSTEM  My\CERTI F~1
202 3-11-19  14:13:06€, Info  SPVERBO SE: Conv)•ng :ƒic rosoft\N€etwork\ ; nections\PbkÏ$WI NDOWS.~B¢T 'wOS:R_€‹”!†KONNEC ’ J1Attempt ¼ to r emove ta@rget f€He r (repar se): \\?0\c:\Ğ|:vRe sult (KRpNL) €)¥šy -> -~u (n o short `name)ÿ:À:RøLBKÁ:(Ö!µÙİG°­ú¿Y_}a}_}ÆL ocal\Pac kages\15 27c705-8 39a-4832 -9118-54 d4Bd6a0c 89_cw5n1 h2txyewyğ\Sys`gÄ—‚åœ?	b«Ğ6ğC7ÿ …Åª¿P¢§ƒ D©¿…¿…ÿô¤ß"ß"È"¿¯¦Gÿ‰ÿK×h¶ÿÿéî(eA_’¨% íêÅ%_’??0Ï7Ï7Ï7Ï7OZa\ÿï/>/>/>T_Œ_7?ü27_7ŒŒŒM”,Up.In telGraph icsExper ience_8j 3eq9eme6øcttïL_~ON?ğŸ¯t¡-PP UP~1.INTÿ¢Ï>_¡,D¯Lÿ/Ÿ? = /// oÿom?L?‘ï·à·Ÿ#Ÿ#ÿŸ#Ÿ#ÏKw___ıP _KßÀßÀ_KD£_KÿÊÊ////±‚o#ıo#pïïïJÏÎÿ_5¿Ö¿ÖÖ'Ş¯J¯J
˜ c5e2524a -ea46-4f 67-841f- 6a9465d9ğd515˜˜ÙÿŸŸb!K//xC5E ˜¿ì¿ì ÿõ_K_K_K_K!!ÿÿÿö<³ a
2023- 11-19 14 :13:06,  Info  SPHVERBOSE : Result  (KRNL)  : \Windo ws.old\U@sers\u 
\ AppData\ Local\Pa ckages\c 5e2524a- ea46-4f6 7-841f-6 a9465d9d 515_cw5n 1h2txyew y\SystemAO -> -ag( SYSTEM~1B)B—RLBK—Cš:l˜|€8_Ë|FÁ«‚C5E€‚~1\EZ:ZConver@ting: ¢<E 2A4F912- 2574-4A7 5-9BB0-0D Ç378592BY¢<$WIND OWS.~BT\àNewOS ¦>ÂZ§ßtÃüWAt`opÁ*  to remo ve target f@~er ( reparse)€\?\c:\ß"ÿ0ƒß"û1¿Gh›¿š¿š¨šÿ{¿š£§ÿü¿šŸÀÿˆÀ¿šÔÀo?`¿ÿ¼¿šÜc¿n¿í¡í¿šìëF46D400 0-FD22-4 DB4-AC8E -4E1DDDEà828FE_M÷u_Mÿ_M}€}ˆ_MŸvÿßŒßŒ  t?ÿ_M_M_MÏ^/(ıooÿog_M¿švM_M¿š¿šşr¿šÓF¿¿¿·_Mÿ?¡1¡x_M¯­ÿ¯­Å ®­_MÏ­¿)?0Ï7ÏÏ7Ê­_M/´s\ïïÿïç¿šo,o,aE_7_7?_7V7†_M_ÃZÃMi crosoft. 549981C3 F5F10_8w ekyb3d8bøbwe‹ÂLLO@?¿¿½¿K¯¡IC ROS~1Q\_¯ÿßØ‹£ ÿK_™_™_™ÏªÿzòÚßßÜ/K/K†ÿ/K/K/K/Käåï
ï
ì
ÿ_J_JQJ¯¯­IIII4÷II'=-"³ 981C3F5F 10_8weky b3d8bbwe \SystemA ppData|C :\Users\
u \T\Loc al\Packa ges\Micr osoft.54
9$°FZWind€ows.old!f€ICROS~1e \SYSTEM~ 1
2023- 11-19 14 :13:06,  Info  SPVERBOSE : Conver0ting€«tAA D.Broker Plugin_c w5n1h2txyewy¢$WI NDOWS.~B€T\NewOS*¬*7‚­ ÛÅSBROúSAt@ŒpQ to  remove  target fÀver (rep arse): \À\?\c:\?Dæ_úˆResult €(KRNL) €/,­ÆÆ©p -> -Ó?ˆÔ£ (EÏ)_#ˆhÃÍgE#RLBKA#€…ÿŸ#‡Ÿ#Ÿ’•’hÿ’~aÎŸÿhÿ’Á,ÿ’?°A€ccounts@›ğtrolß’ß’gZ¿FÉ¿’ƒÉ¥)ACCÿ¿’¸¼¿’¿’ß´ëß¿/Fëÿ?o?oŸ’Ãøö_lTÿ?IÏß¿(/r€†/I}ù¿  /IÓZ/IO†ÿ¯µŒ¯¯¤o’Á“¯ı¯nO:¼ƒIÿ˜ı˜/4ş~’’'m’/¡/¡"¡AsyncTe xtServicşeï¦›]pIIï?ß­e/I?!ñ­öSYÿ/I§ˆ;¤ ô/I’’ÿŸ£¿¿&¶&?IÏ´Æ="’ß½OÄOÄ.ÿ#ÊUeOIOILIÿÿ¿ô_I_I_I_I’\’ûÖÖtÏßÛßÛßÛßÛÿĞÛë|__X4ÿIÜ'IIIrIBPßWeatheşr/I/I¿ÛŸŸŸ¯=®=UBINßHßHè¤ ‘;³    Attem pting to  remove  target f older (r eparse):  \\?\c:\ $WINDOWS .~BT\New OS\Users\u 
\AppD ata\Loca l\Packag es\Micro@soft.B ÚW eather_8 wekyb3d8 bbwe\Sys @
2023 -11-19 1 4:13:06,` Info ¸SPVERBOS E: Resul t (KRNL)  ¹Windows. ÓQ¬ -> -R,(SYSTEM~1)BˆRLB¢KˆC:\\‰|€3¿……|Fì.IC ROS~1.BIN\ÅSºSConv$erÁÍ: î9oE nrollmen t_cw5n1h€2txyewyÀ_Á9¾Úå¢*ß5M')Oÿ?)8u¿!b—ÿ_CÈ__ô¤ßÂŸÿO°_Cßÿ±è±ßßÇşibág?ZéÒÿ_Ïßg_Ü¡NFÜ_6ğ CredDialàogHos?HHx?Hÿï~2ï~å~ÏO#ƒ£]Ç/¾µCREOHï‚ÿÈ:¤ 4;OHßßß/ÿïï¿2_Hûrßš­Bïïã¿oHs¿¿¿» Hû¡¡ ocHŸ¡-ÿj¬H²	²Ÿ?Ÿ”ŸH¸m@ß3~1÷oÏ¶´3 NŸH¿À¿À²ÀDesktop@_Installÿ?Á9ÁïHïHoj_È	P>N-UDESÿ?I?IÆ]?I?I?I?Iÿ/8u8??8Ï"Ï"÷mŸÙŸÙdÔtfäOÿOHßI#4__¿)ÿêşa/J¯ë±ß4¥ë/J/J¿.¿.ß5÷³ we\Syste mAppData |C:\User(s\u (\¨\L ocal\Pac kages\Mi crosoft.€Desktop N Installe r_8wekyb 3d8bb¼FÀ Windows.old!ØICRO S~1.DES\ SYSTEM~1 
2023-1 1-19 14: 13:06, Info  SP VERBOSE:  Convert˜ing «wEC ušp  $WINDO WS.~BT\NğewOSª©Ÿ1‚¢ Ó§…œ€(ºœAt@ˆpL  to remo ve target f@qer ( reparse) : \\?\c:2\AppYZº€Re sult (KRğNL) À,ì¤Àk` -> -ÿ	é (…Á)?A€ RLBşK @Wß ó€Ş ‹‹û
_‰aî–b_‰a‰_‰_§GetHelZ\Ÿ&ßhÀ¶´¿a|ß‰ƒ£¾£'2.GETß‰¿±ß‰ß‰ŸªëIÿ aiÂÈƒ mÊŠ?ê"êaw_ŠÍôŸ
aOEÏu? ş “UOEÿ~"‡¿+Å…ÿ_…0Kp//?Š}ß"E‘‘¯1~?Š?Š%m?Š?™?™$ ˜røtedïs›¿EjOTß¶oğ/ïEpqNı31ïE‘4ïEÿßŠßŠ?›%%x%¯®ÿF_«&!!Fo´?»?»ö.o¯ºtOFä1??ÿ'w'FFFFåFÿFÿ&JÌ¯ÑÓïÿïïh8ßFßFßFÑxÿÑÑ&½%ßFßFßFÒF@HEIFIm ‚E xtensionÿïèğZ_G_G_GVGÿ         previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;
