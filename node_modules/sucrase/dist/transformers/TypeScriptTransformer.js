"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _types = require('../parser/tokenizer/types');

var _isIdentifier = require('../util/isIdentifier'); var _isIdentifier2 = _interopRequireDefault(_isIdentifier);

var _Transformer = require('./Transformer'); var _Transformer2 = _interopRequireDefault(_Transformer);

 class TypeScriptTransformer extends _Transformer2.default {
  constructor(
     rootTransformer,
     tokens,
     isImportsTransformEnabled,
  ) {
    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.isImportsTransformEnabled = isImportsTransformEnabled;;
  }

  process() {
    if (
      this.rootTransformer.processPossibleArrowParamEnd() ||
      this.rootTransformer.processPossibleAsyncArrowWithTypeParams() ||
      this.rootTransformer.processPossibleTypeRange()
    ) {
      return true;
    }
    if (
      this.tokens.matches1(_types.TokenType._public) ||
      this.tokens.matches1(_types.TokenType._protected) ||
      this.tokens.matches1(_types.TokenType._private) ||
      this.tokens.matches1(_types.TokenType._abstract) ||
      this.tokens.matches1(_types.TokenType._readonly) ||
      this.tokens.matches1(_types.TokenType._override) ||
      this.tokens.matches1(_types.TokenType.nonNullAssertion)
    ) {
      this.tokens.removeInitialToken();
      return true;
    }
    if (this.tokens.matches1(_types.TokenType._enum) || this.tokens.matches2(_types.TokenType._const, _types.TokenType._enum)) {
      this.processEnum();
      return true;
    }
    if (
      this.tokens.matches2(_types.TokenType._export, _types.TokenType._enum) ||
      this.tokens.matches3(_types.TokenType._export, _types.TokenType._const, _types.TokenType._enum)
    ) {
      this.processEnum(true);
      return true;
    }
    return false;
  }

  processEnum(isExport = false) {
    // We might have "export const enum", so just remove all relevant tokens.
    this.tokens.removeInitialToken();
    while (this.tokens.matches1(_types.TokenType._const) || this.tokens.matches1(_types.TokenType._enum)) {
      this.tokens.removeToken();
    }
    const enumName = this.tokens.identifierName();
    this.tokens.removeToken();
    if (isExport && !this.isImportsTransformEnabled) {
      this.tokens.appendCode("export ");
    }
    this.tokens.appendCode(`var ${enumName}; (function (${enumName})`);
    this.tokens.copyExpectedToken(_types.TokenType.braceL);
    this.processEnumBody(enumName);
    this.tokens.copyExpectedToken(_types.TokenType.braceR);
    if (isExport && this.isImportsTransformEnabled) {
      this.tokens.appendCode(`)(${enumName} || (exports.${enumName} = ${enumName} = {}));`);
    } else {
      this.tokens.appendCode(`)(${enumName} || (${enumName} = {}));`);
    }
  }

  /**
   * Transform an enum into equivalent JS. This has complexity in a few places:
   * - TS allows string enums, numeric enums, and a mix of the two styles within an enum.
   * - Enum keys are allowed to be referenced in later enum values.
   * - Enum keys are allowed to be strings.
   * - When enum values are omitted, they should follow an auto-increment behavior.
   */
  processEnumBody(enumName) {
    // Code that can be used to reference the previous enum member, or null if this is the first
    // enum member.
    let previousValueCode = null;
    while (true) {
      if (this.tokens.matches1(_types.TokenType.braceR)) {
        break;
      }
      const {nameStringCode, variableName} = this.extractEnumKeyInfo(this.tokens.currentToken());
      this.tokens.removeInitialToken();

      if (
        this.tokens.matches3(_types.TokenType.eq, _types.TokenType.string, _types.TokenType.comma) ||
        this.tokens.matches3(_types.TokenType.eq, _types.TokenType.string, _types.TokenType.braceR)
      ) {
        this.processStringLiteralEnumMember(enumName, nameStringCode, variableName);
      } else if (this.tokens.matches1(_types.TokenType.eq)) {
        this.processExplicitValueEnumMember(enumName, nameStringCode, variableName);
      } else {
        this.processImplicitValueEnumMember(
          enumName,
          nameStringCode,
          variableName,
          previousValueCode,
        );
      }
      if (this.tokens.matches1(_types.TokenType.comma)) {
        this.tokens.removeToken();
      }

      if (variableName != null) {
        previousValueCode = variableName;
      } else {
        previousValueCode = `${enumName}[${nameStringCode}]`;
      }
    }
  }

  /**
   * Detect name information about this enum key, which will be used to determine which code to emit
   * and whether we should declare a variable as part of this declaration.
   *
   * Some cases to keep in mind:
   * - Enum keys can be implicitly referenced later, e.g. `X = 1, Y = X`. In Sucrase, we implement
   *   this by declaring a variable `X` so that later expressions can use it.
   * - In addition to the usual identifier key syntax, enum keys are allowed to be string literals,
   *   e.g. `"hello world" = 3,`. Template literal syntax is NOT allowed.
   * - Even if the enum key is defined as a string literal, it may still be referenced by identifier
   *   later, e.g. `"X" = 1, Y = X`. That means that we need to detect whether or not a string
   *   literal is identifier-like and emit a variable if so, even if the declaration did not use an
   *   identifier.
   * - Reserved keywords like `break` are valid enum keys, but are not valid to be referenced later
   *   and would be a syntax error if we emitted a variable, so we need to skip the variable
   *   declaration in those cases.
   *
   * The variableName return value captures these nuances: if non-null, we can and must emit a
   * variable declaration, and if null, we can't and shouldn't.
   */
  extractEnumKeyInfo(nameToken) {
    if (nameToken.type === _types.TokenType.name) {
      const name = this.tokens.identifierNameForToken(nameToken);
      return {
        nameStringCode: `"${name}"`,
        variableName: _isIdentifier2.default.call(void 0, name) ? name : null,
      };
    } else if (nameToken.type === _types.TokenType.string) {
      const name = this.tokens.stringValueForToken(nameToken);
      return {
        nameStringCode: this.tokens.code.slice(nameToken.start, nameToken.end),
        variableName: _isIdentifier2.default.call(void 0, name) ? name : null,
      };
    } else {
      throw new Error("Expected name or string at beginning of enum element.");
    }
  }

  /**
   * Handle an enum member where the RHS is just a string literal (not omitted, not a number, and
   * not a complex expression). This is the typical form for TS string enums, and in this case, we
   * do *not* create a reverse mapping.
   *
   * This is called after deleting the key token, when the token processor is at the equals sign.
   *
   * Example 1:
   * someKey = "some value"
   * ->
   * const someKey = "some value"; MyEnum["someKey"] = someKey;
   *
   * Example 2:
   * "some key" = "some value"
   * ->
   * MyEnum["some key"] = "some value";
   */
  processStringLiteralEnumMember(
    enumName,
    nameStringCode,
    variableName,
  ) {
    if (variableName != null) {
      this.tokens.appendCode(`const ${variableName}`);
      // =
      this.tokens.copyToken();
      // value string
      this.tokens.copyToken();
      this.tokens.appendCode(`; ${enumName}[${nameStringCode}] = ${variableName};`);
    } else {
      this.tokens.appendCode(`${enumName}[${nameStringCode}]`);
      // =
      this.tokens.copyToken();
      // value string
      this.tokens.copyToken();
      this.tokens.appendCode(";");
    }
  }

  /**
   * Handle an enum member initialized with an expression on the right-hand side (other than a
   * string literal). In these cases, we should transform the expression and emit code that sets up
   * a reverse mapping.
   *
   * The TypeScript implementation of this operation distinguishes between expressions that can be
   * "constant folded" at compile time (i.e. consist of number literals and simple math operations
   * on those numbers) and ones that are dynamic. For                              5 5 3  
 ; P R E W 2 K C O M P A C C E S S                               5 5 4  
 ; R E M O T E _ D E S K T O P _ U S E R S                       5 5 5  
 ; N E T W O R K _ C O N F I G U R A T I O N _ O P S             5 5 6  
 ; L O G G I N G _ U S E R S                                     5 5 9  
 ;  
 ; W d i S e r v i c e H o s t                                   S - 1 - 5 - 8 0 - 3 1 3 9 1 5 7 8 7 0 - 2 9 8 3 3 9 1 0 4 5 - 3 6 7 8 7 4 7 4 6 6 - 6 5 8 7 2 5 7 1 2 - 1 8 0 9 3 4 0 4 2 0  
 ; A L L   S E R V I C E S 	 	 	 S - 1 - 5 - 8 0 - 0  
  
 S e A s s i g n P r i m a r y T o k e n P r i v i l e g e   =   A d d : ,   * S - 1 - 5 - 1 9 ,   * S - 1 - 5 - 2 0  
 S e A u d i t P r i v i l e g e   =   A d d : ,   * S - 1 - 5 - 1 9 ,   * S - 1 - 5 - 2 0  
 S e B a t c h L o g o n R i g h t   =   A d d : ,   * S - 1 - 5 - 3 2 - 5 4 4 ,   * S - 1 - 5 - 3 2 - 5 5 1 ,   * S - 1 - 5 - 3 2 - 5 5 9  
 S e C h a n g e N o t i f y P r i v i l e g e   =   A d d : ,   * S - 1 - 5 - 1 9 ,   * S - 1 - 5 - 2 0  
 S e C r e a t e G l o b a l P r i v i l e g e   =   A d d : ,   * S - 1 - 5 - 6 ,   * S - 1 - 5 - 3 2 - 5 4 4 ,   * S - 1 - 5 - 1 9 ,   * S - 1 - 5 - 2 0 ,   R e m o v e : ,   * S - 1 - 5 - 4  
 S e C r e a t e S y m b o l i c L i n k P r i v i l e g e   =   A d d : ,   * S - 1 - 5 - 3 2 - 5 4 4  
 S e I m p e r s o n a t e P r i v i l e g e   =   A d d : ,   * S - 1 - 5 - 6 ,   * S - 1 - 5 - 3 2 - 5 4 4 ,   * S - 1 - 5 - 1 9 ,   * S - 1 - 5 - 2 0  
 S e I n c r e a s e B a s e P r i o r i t y P r i v i l e g e   =   A d d : ,   * S - 1 - 5 - 9 0 - 0  
 S e I n c r e a s e Q u o t a P r i v i l e g e   =   A d d : ,   * S - 1 - 5 - 1 9 ,   * S - 1 - 5 - 2 0  
 S e I n c r e a s e W o r k i n g S e t P r i v i l e g e   =   A d d : ,   * S - 1 - 5 - 3 2 - 5 4 5  
 S e M a n a g e V o l u m e P r i v i l e g e   =   A d d : ,   * S - 1 - 5 - 3 2 - 5 4 4  
 S e R e m o t e I n t e r a c t i v e L o g o n R i g h t   =   A d d : ,   * S - 1 - 5 - 3 2 - 5 4 4 ,   * S - 1 - 5 - 3 2 - 5 5 5  
 ; S e R e m o t e S h u t d o w n P r i v i l e g e   =   R e m o v e : ,   * S - 1 - 5 - 3 2 - 5 4 7  
 S e S y s t e m P r o f i l e P r i v i l e g e   =   A d d : ,   * S - 1 - 5 - 8 0 - 3 1 3 9 1 5 7 8 7 0 - 2 9 8 3 3 9 1 0 4 5 - 3 6 7 8 7 4 7 4 6 6 - 6 5 8 7 2 5 7 1 2 - 1 8 0 9 3 4 0 4 2 0  
 S e S y s t e m T i m e P r i v i l e g e   =   A d d : ,   * S - 1 - 5 - 1 9 ,   R e m o v e : ,   * S - 1 - 5 - 2 0  
 S e T i m e Z o n e P r i v i l e g e   =   A d d : ,   * S - 1 - 5 - 3 2 - 5 4 4 ,   * S - 1 - 5 - 1 