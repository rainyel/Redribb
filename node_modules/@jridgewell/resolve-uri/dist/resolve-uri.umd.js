(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());
})(this, (function () { 'use strict';

    // Matches the scheme of a URL, eg "http://"
    const schemeRegex = /^[\w+.-]+:\/\//;
    /**
     * Matches the parts of a URL:
     * 1. Scheme, including ":", guaranteed.
     * 2. User/password, including "@", optional.
     * 3. Host, guaranteed.
     * 4. Port, including ":", optional.
     * 5. Path, including "/", optional.
     * 6. Query, including "?", optional.
     * 7. Hash, including "#", optional.
     */
    const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
    /**
     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
     *
     * 1. Host, optional.
     * 2. Path, which may include "/", guaranteed.
     * 3. Query, including "?", optional.
     * 4. Hash, including "#", optional.
     */
    const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
    }
    function isSchemeRelativeUrl(input) {
        return input.startsWith('//');
    }
    function isAbsolutePath(input) {
        return input.startsWith('/');
    }
    function isFileUrl(input) {
        return input.startsWith('file:');
    }
    function isRelative(input) {
        return /^[.?#]/.test(input);
    }
    function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
    }
    function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path = match[2];
        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
    }
    function makeUrl(scheme, user, host, port, path, query, hash) {
        return {
            scheme,
            user,
            host,
            port,
            path,
            query,
            hash,
            type: 7 /* Absolute */,
        };
    }
    function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
            const url = parseAbsoluteUrl('http:' + input);
            url.scheme = '';
            url.type = 6 /* SchemeRelative */;
            return url;
        }
        if (isAbsolutePath(input)) {
            const url = parseAbsoluteUrl('http://foo.com' + input);
            url.scheme = '';
            url.host = '';
            url.type = 5 /* AbsolutePath */;
            return url;
        }
        if (isFileUrl(input))
            return parseFileUrl(input);
        if (isAbsoluteUrl(input))
            return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl('http://foo.com/' + input);
        url.scheme = '';
        url.host = '';
        url.type = input
            ? input.startsWith('?')
                ? 3 /* Query */
                : input.startsWith('#')
                    ? 2 /* Hash */
                    : 4 /* RelativePath */
            : 1 /* Empty */;
        return url;
    }
    function stripPathFilename(path) {
        // If a path ends with a parent directory "..", then it's a relative path with excess parent
        // paths. It's not a file, so we can't strip it.
        if (path.endsWith('/..'))
            return path;
        const index = path.lastIndexOf('/');
        return path.slice(0, index + 1);
    }
    function mergePaths(url, base) {
        normalizePath(base, base.type);
        // If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
        // path).
        if (url.path === '/') {
            url.path = base.path;
        }
        else {
            // Resolution happens relative to the base path's directory, not the file.
            url.path = stripPathFilename(base.path) + url.path;
        }
    }
    /**
     * The path can have empty directories "//", unneeded parents "foo/..", or current directory
     * "foo/.". We need to normalize to a standard representation.
     */
    function normalizePath(url, type) {
        const rel = type <= 4 /* RelativePath */;
        const pieces = url.path.split('/');
        // We need to preserve the first piece always, so that we output a leading slash. The item at
        // pieces[0] is an empty string.
        let pointer = 1;
        // Positive is the number of real directories we've output, used for popping a parent directory.
        // Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
        let positive = 0;
        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
        // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
        // real directory, we won't need to append, unless the other conditions happen again.
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
            const piece = pieces[i];
            // An empty directory, could be a trailing slash, or just a double "//" in the path.
            if (!piece) {
                addTrailingSlash = true;
                continue;
            }
            // If we encounter a real directory, then we don't need to append anymore.
            addTrailingSlash = false;
            // A current directory, which we can always drop.
            if (piece === '.')
                continue;
            // A parent directory, we need to see if there are any real directories we can pop. Else, we
            // have an excess of parents, and we'll need to keep the "..".
            if (piece === '..') {
                if (positive) {
                    addTrailingSlash = true;
                    positive--;
                    pointer--;
                }
                else if (rel) {
                    // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
                    // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
                    pieces[pointer++] = piece;
                }
                continue;
            }
            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
            // any popped or dropped directories.
            pieces[pointer++] = piece;
            positive++;
        }
        let path = '';
        for (let i = 1; i < pointer; i++) {
            path += '/' + pieces[i];
        }
        if (!path || (addTrailingSlash && !path.endsWith('/..'))) {
            path += '/';
        }
        url.path = path;
    }
    /**
     * Attempts to resolve `input` URL/path relative to `base`.
     */
    function resolve(input, base) {
        if (!input && !base)
            return '';
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== 7 /* Absolute */) {
            const baseUrl = parseUrl(base);
            const baseType = baseUrl.type;
            switch (inputType) {
                case 1 /* Empty */:
                    url.hash = baseUrl.hash;
                // fall through
                case 2 /* Hash */:
                    url.query = baseUrl.query;
                // fall through
                case 3 /* Query */:
                case 4 /* RelativePath */:
                    mergePaths(url, baseUrl);
                // fall through
                case 5 /* AbsolutePath */:
                    // The host, user, and port are joined, you can't copy one without the others.
                    url.user = baseUrl.user;
                    url.host = baseUrl.host;
                    url.port = baseUrl.port;
                // fall thrö"»Ö¶ô¬¶šÍô	ƒ®z©Å‡³Šº„ü¸úïhï•ï´nÈÉT=ÇêA6$`QëeTÍ¯·™uşm×Eãl$à‰
ïëúğí°@«MÛ}ÍDÅÎK”çe0².îÊ¼şlAÇûóÙ÷Ñ‘b57ù>“İ,$5D:â„câJ0jVìˆô¢½°®GÅü¿I*RAÔ7++´$2ª£T[5;7úöóq÷ÏçÃ]8eC¯=ÁêğWç€üñ¹äI—ÏÈy~"í¨ğî®å‡zÎjm‘WãÁXAƒ{¹¹]‘QNĞ)uÛ@İ±V¢Á&ˆÈ6¯~€®®uí5)äLS©Ğ}!ÔØmÛZÛ,ë¬=ıo–óP øêûèºÔÂùïLGs>sk6]ô5iË©õŒÆN¾ –í_R„´Ã•*ÕCÓXœ—™píO¸dúh1ÓmûSû¶›†‰0›ùÄ|RÂÖ°ürŠûéºú²v; è«åwh’ŞÅ¡¯GšÚfdUÜÿ›@§ÚIKv?]Û	Cß³Ğëk&‹c£Aõ¬Z&µÁkİ2ß„–%PºàÓ ¸˜ÌYï°Ù…-·¤—È0åæP­Î#×ß!¬øíÈSêï:Ù‘–ÄÚÒkZw79İĞ-ç¸§æ3H,\µ€Í·'OEÂòpÎÚ+È-§‰ò§$
¹t ìİÔ¶™ª{÷^O…ÿ,R7óƒws§=f„Ó¦É˜fy1à³X³µµFUœß$ñO"²EĞ_Z×aá^Glò[„X¹‚HŒ"ºµ*|m¢n™¾Ø1ARÅıw]Ó\u)¥fµƒÒĞ4ÔbĞœ¢1×(Ï±Ú·õ›“¤Ö)	’Ñ_z×ˆ„±„ÿ-X†l¨ƒ•L›géKøñøòÂHR(°ë¾‘ÉL¨NgÀhm%h ¦=M\–$D[ÿş–PSLØµOç±Rî#´N:fñúTc…Kß&«† õ)…KàDñÂ]!-ÈXj$zvÍbZ Ô¨§SeõH£8ükh©ñc—îz¢ø=Ùİvômë}£¶G¿EW#C1]ÿÈ1 õ‹ù¥º6í}õ¶{İ¤õÉQòU^š²Ÿ*¦<'Ï\AûHĞSœLıÂ]Ü×ÊÅ-ÖrßÓsên&*`Ğ:stÚÚšEò¯c j‰Œ'é:'€ŞBà){Şªt*{ó4tHlwr­Á#m²çãÄ "Ø	éÁŠûïÚ2·ÊY$aU¬AÖMåôQ¿C©eXò»jÆs¨0^Z–‡èÚíºÆhÂÜŸ2İm/bè›§Sä§KDà‰Õ‘¬Gê‡éZk0­'fÏ?eº±lœºÚ@¢ëº<8!FĞÙ7PßG×å¥‰TX-±~mèFh)·Õ®SâÎ&hBëdÄC¡ éü {ê®ÛÅÔ$Ü—4 »³÷njöÁ²jB—V#òüdr4¡N	¬…H,oĞ5<¿re›Í4h.+féhÚB8S9\w®¸ìÏˆ+°>¡1?}×y˜·sÓÎŸ›­¸R\2C]ÓkòÓã
šÜ7èoÑÒR+ÑÚ£6ë}³Œ'Ñn¶öïNR5!ùbšÁ;Ö7êú(üÍrtì¤è%!Ğ´J‚f††Û3şYq¤‰ùÍº6f©ÀöáEòzô3•rê¢ ë÷Å&šòfÍŸcõĞ¼E×%vë¥æ×¶’òİ£>ÁÆ‘ÖrVı„Ö÷b›æÍºJANû„•›™èS2t=ÌÊjÊo;mL¤xéŸ_Ğ86˜Ş´k­oüHzÌ„¨İ™è´Ü;©ô­‡5°Æ­íŸK
Se£ş)È©¡=í“v=zÍ;EºÂFT¨B1CdX®V9X‹fÚÅ/PkºLOÙuÌÿ*’¶.¶‘/=—|slú7h?uÂõãêAÛSuİ8Ù=VØÔôœdPá±Î«>İB?4MÈOŠ¨›tLOÒõ¨d-¯½àŸ­cfAFLA®©ÑìšZáÇ‰¨mLOÒ5¿µş°Y*,­ÑCÕÓÛ–›r¨Ğ3éÿqâj -ŸÆY—Xßôy;g¦³>9!=­+ôê÷–ÇŸK|t†—ï
µ€d×÷åğIßq»-¹OCºxŒ²æ}ôxz: